"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KoiiStorageClient = void 0;
const web3_js_1 = require("@_koii/web3.js");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const crypto_1 = __importDefault(require("crypto"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const bs58_1 = __importDefault(require("bs58"));
class KoiiStorageClient {
    constructor(storageTaskId, k2URL = 'https://testnet.koii.network', debug = false) {
        this.trustedNodes = ['https://ipfs-gateway.koii.live', 'https://tasknet.koii.live', 'https://tasknet-2.koii.live'];
        if (storageTaskId)
            this.storageTaskId = storageTaskId;
        else
            this.storageTaskId = 'BWfeCA4gyVKpmKGpq6MDHir16p7i2Er1e8XEHQj7z7zm';
        this.k2URL = k2URL;
        this.debug = debug;
        this.watchTaskState();
    }
    watchTaskState() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getTaskState();
            setInterval(() => {
                this.getTaskState();
            }, 10 * 60 * 1000);
        });
    }
    uploadFile(file, stakingWallet) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!stakingWallet)
                throw new Error('Staking wallet is required');
            const nodesUrls = yield this.getNodesRunningTask(7);
            if (this.debug)
                console.log(nodesUrls);
            const formData = new FormData();
            let fileData;
            if (typeof file === 'string') {
                // Normalize the file path
                const normalizedPath = path_1.default.normalize(file).replace(/\\/g, '/');
                // If a single file path is provided, read the file synchronously
                fileData = fs_1.default.readFileSync(normalizedPath);
                const fileBlob = new Blob([fileData]);
                const filename = path_1.default.basename(file);
                formData.append('files', fileBlob, filename);
            }
            else if (file instanceof File) {
                // If a single File object is provided
                fileData = Buffer.from(yield file.arrayBuffer());
                formData.append('files', file);
                // formData.append('name', file.name);
            }
            else if (Array.isArray(file)) {
                // If an array of File objects is provided
                const fileBuffers = yield Promise.all(file.map((f) => __awaiter(this, void 0, void 0, function* () { return Buffer.from(yield f.arrayBuffer()); })));
                fileData = Buffer.concat(fileBuffers);
                file.forEach((f) => {
                    formData.append('files', f);
                    // formData.append('name', f.name);
                });
            }
            else {
                throw new Error('Invalid file input');
            }
            const fileHash = yield this.hashFileData(fileData);
            const signature = yield this.signingFileHash(fileHash, stakingWallet);
            formData.append('signature', signature);
            formData.append('stakingWalletPubkey', stakingWallet.publicKey.toBase58());
            const errorList = [];
            const promises = nodesUrls.map((nodeUrl) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const response = yield this.fetchWithTimeout(`${nodeUrl}/task/${this.storageTaskId}/ipfs/add`, {
                        // const response = await fetch(`http://localhost:20001/ipfs/add`, {
                        method: 'POST',
                        body: formData,
                    });
                    if (!response.ok) {
                        if (this.debug)
                            console.error(response.status, response.statusText);
                        let responseText = yield response.text();
                        throw new Error(`Failed to upload file ${response.status} - ${response.statusText} - ${responseText}`);
                    }
                    return yield response.json();
                }
                catch (error) {
                    if (this.debug)
                        console.error('Error Uploading file to node:', nodeUrl, error.message);
                    errorList.push(error);
                    return null; // Return null if there's an error
                }
            }));
            const responses = yield Promise.all(promises);
            // Filter out null responses and return the first valid response
            let successResp = responses.filter((response) => response !== null)[0];
            if (!successResp) {
                throw new Error('Failed to upload file' + errorList[errorList.length - 1]);
            }
            return successResp;
        });
    }
    getFile(cid, filename) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodesUrls = yield this.getNodesRunningTask(5);
            let response;
            for (let nodeUrl of nodesUrls) {
                try {
                    response = yield this.fetchWithTimeout(`${nodeUrl}/task/${this.storageTaskId}/ipfs/${cid}/${filename}`);
                    if (!response.ok) {
                        if (this.debug)
                            console.error(response.status, response.statusText);
                        throw new Error('Failed to fetch file from node');
                    }
                    const data = yield response.blob();
                    return data;
                }
                catch (error) {
                    if (this.debug)
                        console.error('Error fetching file from node:', nodeUrl, error.message);
                }
            }
            throw new Error('Cannot fetch the file: ' + (response === null || response === void 0 ? void 0 : response.statusText));
        });
    }
    signingFileHash(fileHash, stakingWallet) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new TextEncoder().encode(fileHash);
            const signedMessage = tweetnacl_1.default.sign(msg, stakingWallet.secretKey);
            return yield this.bs58Encode(signedMessage);
        });
    }
    hashFileData(fileData_1) {
        return __awaiter(this, arguments, void 0, function* (fileData, algorithm = 'sha256') {
            const hash = crypto_1.default.createHash(algorithm);
            hash.update(fileData);
            return hash.digest('hex');
        });
    }
    bs58Encode(data) {
        return bs58_1.default.encode(Buffer.from(data.buffer, data.byteOffset, data.byteLength));
    }
    getTaskState() {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = new web3_js_1.Connection(this.k2URL);
            let accountInfo;
            try {
                accountInfo = yield connection.getAccountInfo(new web3_js_1.PublicKey(this.storageTaskId));
            }
            catch (error) {
                this.taskState = {};
                return;
            }
            if (!accountInfo) {
                this.taskState = {};
                return;
            }
            const taskState = JSON.parse(accountInfo.data + '');
            this.taskState = taskState;
            if (!taskState.is_active)
                throw new Error('Storage task is not active');
        });
    }
    getNodesRunningTask(count) {
        return __awaiter(this, void 0, void 0, function* () {
            let counter = 0;
            while (!this.taskState) {
                counter += 1;
                if (counter > 100)
                    break;
                if (this.debug)
                    console.log('Waiting for taskState fetching');
                yield this.sleep(500);
            }
            const state = this.taskState;
            if (!state || !state.submissions) {
                if (this.debug)
                    console.log('Not able to fetch all nodes, falling back to trusted nodes');
                return this.trustedNodes;
            }
            let totalSubmissionKeys = Object.keys(state.submissions);
            const lastRound = totalSubmissionKeys[totalSubmissionKeys.length - 1];
            let lastRoundSubmissionKeys = Object.keys(state.submissions[lastRound]);
            let selectedNodes;
            if (lastRoundSubmissionKeys.length > 10) {
                const shuffledArray = this.shuffleArray(lastRoundSubmissionKeys.slice()); // Make a copy to avoid modifying the original array
                selectedNodes = shuffledArray.slice(0, count - 1);
            }
            else {
                selectedNodes = lastRoundSubmissionKeys.map((e) => state.ip_address_list[e]).filter((e) => !!e);
            }
            for (let trustedNode of this.trustedNodes) {
                if (!selectedNodes.includes(trustedNode))
                    selectedNodes.push(trustedNode);
            }
            return selectedNodes;
        });
    }
    saveBlobAsFile(blob, filename) {
        return __awaiter(this, void 0, void 0, function* () {
            // Convert the Blob data to a Buffer
            const buffer = Buffer.from(yield blob.arrayBuffer());
            // Write the Buffer data to a file
            fs_1.default.writeFileSync(filename, buffer);
        });
    }
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    fetchWithTimeout(url, options, timeout = 20000) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        const signal = controller.signal;
        return fetch(url, Object.assign(Object.assign({}, options), { signal })).finally(() => clearTimeout(id));
    }
    static getInstance(options) {
        if (!KoiiStorageClient.instance) {
            KoiiStorageClient.instance = new KoiiStorageClient(options === null || options === void 0 ? void 0 : options.storageTaskId, options === null || options === void 0 ? void 0 : options.k2URL, options === null || options === void 0 ? void 0 : options.debug);
        }
        return KoiiStorageClient.instance;
    }
}
exports.KoiiStorageClient = KoiiStorageClient;
